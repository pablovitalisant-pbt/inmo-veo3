from fastapi import FastAPI, UploadFile, File, Form, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from google.cloud import storage
from prometheus_fastapi_instrumentator import Instrumentator
import os, csv, io, json, datetime, random, string, threading, requests, time

app = FastAPI(title="InmoVeo3 Backend")

# === ConfiguraciÃ³n ===
ARTIFACTS_BUCKET = os.getenv("ARTIFACTS_BUCKET", "inmo-veo3-artifacts-859994227667")
storage_client = storage.Client()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

Instrumentator().instrument(app).expose(app, endpoint="/metrics")

# === Utilidades ===
def get_bucket():
    return storage_client.bucket(ARTIFACTS_BUCKET)

def random_slug():
    ts = datetime.datetime.utcnow().strftime("%Y%m%d-%H%M%S")
    rand = ''.join(random.choices(string.ascii_lowercase + string.digits, k=4))
    return f"{ts}-{rand}"

def write_bytes(path: str, data: bytes, content_type: str):
    blob = get_bucket().blob(path)
    blob.upload_from_string(data, content_type=content_type)

def write_text(path: str, text: str, content_type: str = "text/plain"):
    write_bytes(path, text.encode("utf-8"), content_type)

def read_text(path: str) -> str:
    blob = get_bucket().blob(path)
    if not blob.exists():
        raise HTTPException(status_code=404, detail=f"File not found: {path}")
    return blob.download_as_text()

def list_slugs():
    bucket = get_bucket()
    slugs = set()
    for blob in bucket.list_blobs():
        prefix = blob.name.split("/")[0]
        if prefix:
            slugs.add(prefix)
    return sorted(slugs)

# === Proceso en background (simula pipeline y sube un MP4 real) ===
SAMPLE_VIDEO_URL = "https://storage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4"

def pipeline_job(slug: str):
    prefix = f"{slug}/"
    # cargar/actualizar manifest
    manifest_path = prefix + "manifest.json"
    m = {
        "slug": slug,
        "bucket": ARTIFACTS_BUCKET,
        "status": "running",
        "steps": [
            {"name": "prepare_assets", "status": "running"},
            {"name": "script", "status": "queued"},
            {"name": "voice", "status": "queued"},
            {"name": "video", "status": "queued"},
            {"name": "upload", "status": "queued"},
        ],
        "updated_at": datetime.datetime.utcnow().isoformat() + "Z",
        "outputs": {},
        "error": None,
    }
    write_text(manifest_path, json.dumps(m), "application/json")

    # step: prepare_assets
    time.sleep(1.0)
    m["steps"][0]["status"] = "completed"
    m["steps"][1]["status"] = "running"
    m["updated_at"] = datetime.datetime.utcnow().isoformat() + "Z"
    write_text(manifest_path, json.dumps(m), "application/json")

    # step: script
    write_text(prefix + "script.json", json.dumps({"ok": True}), "application/json")
    time.sleep(0.8)
    m["steps"][1]["status"] = "completed"
    m["steps"][2]["status"] = "running"
    m["updated_at"] = datetime.datetime.utcnow().isoformat() + "Z"
    write_text(manifest_path, json.dumps(m), "application/json")

    # step: voice
    write_bytes(prefix + "voice.wav", b"RIFFxxxxWAVEfmt ", "audio/wav")
    time.sleep(0.8)
    m["steps"][2]["status"] = "completed"
    m["steps"][3]["status"] = "running"
    m["updated_at"] = datetime.datetime.utcnow().isoformat() + "Z"
    write_text(manifest_path, json.dumps(m), "application/json")

    # step: video (descarga sample y sube como result.mp4)
    try:
        r = requests.get(SAMPLE_VIDEO_URL, timeout=60)
        r.raise_for_status()
        write_bytes(prefix + "result.mp4", r.content, "video/mp4")
        m["outputs"]["video"] = "result.mp4"
        m["steps"][3]["status"] = "completed"
        m["steps"][4]["status"] = "running"
        m["updated_at"] = datetime.datetime.utcnow().isoformat() + "Z"
        write_text(manifest_path, json.dumps(m), "application/json")
    except Exception as e:
        m["status"] = "failed"
        m["error"] = {"message": str(e), "stage": "video"}
        m["updated_at"] = datetime.datetime.utcnow().isoformat() + "Z"
        write_text(manifest_path, json.dumps(m), "application/json")
        return

    # step: upload (completado)
    time.sleep(0.5)
    m["steps"][4]["status"] = "completed"
    m["status"] = "completed"
    m["updated_at"] = datetime.datetime.utcnow().isoformat() + "Z"
    write_text(manifest_path, json.dumps(m), "application/json")

@app.get("/health")
def health():
    return {"status": "ok"}

@app.post("/run")
async def run(file: UploadFile = File(None), notes: str = Form(None)):
    slug = random_slug()
    prefix = slug + "/"
    manifest = {
        "slug": slug,
        "created_at": datetime.datetime.utcnow().isoformat() + "Z",
        "notes": notes,
        "bucket": ARTIFACTS_BUCKET,
        "status": "queued",
    }
    write_text(prefix + "manifest.json", json.dumps(manifest), "application/json")

    # CSV (demo)
    csv_buf = io.StringIO()
    writer = csv.writer(csv_buf)
    writer.writerow(["id", "value"])
    writer.writerow(["1", "100"])
    writer.writerow(["2", "200"])
    write_text(prefix + "results.csv", csv_buf.getvalue(), "text/csv")

    if file:
        content = await file.read()
        write_text(prefix + file.filename, content.decode("utf-8", "ignore"), file.content_type or "text/plain")

    # Lanzar pipeline en segundo plano
    threading.Thread(target=pipeline_job, args=(slug,), daemon=True).start()
    return {"slug": slug, "bucket": ARTIFACTS_BUCKET}

@app.get("/artifacts")
def get_artifacts():
    slugs = list_slugs()
    return {"slugs": slugs, "count": len(slugs)}

@app.get("/artifacts/{slug}")
def get_artifact(slug: str):
    prefix = f"{slug}/"
    try:
        manifest_json = read_text(prefix + "manifest.json")
        results_csv = read_text(prefix + "results.csv")
    except HTTPException:
        raise HTTPException(status_code=404, detail=f"Artifact {slug} not found")
    return {"slug": slug, "manifest": json.loads(manifest_json), "results_csv": results_csv}

# === Firma temporal de GCS (para previsualizar el video en la UI) ===
from datetime import timedelta

def blob_exists(path: str) -> bool:
    return get_bucket().blob(path).exists()

@app.get("/artifacts/{slug}/result_url")

@app.get("/artifacts/{slug}/result_url")
def get_result_signed_url(slug: str, minutes: int = 60):
    """Devuelve una URL firmada para reproducir result.mp4 en la UI."""
    from google.auth.transport import requests
    from google.auth import default as google_auth_default
    import google.auth.iam
    from datetime import timedelta

    path = f"{slug}/result.mp4"
    blob = get_bucket().blob(path)
    if not blob.exists():
        raise HTTPException(status_code=404, detail="result.mp4 not found")

    # Usa la cuenta de servicio del servicio de Cloud Run como signer
    credentials, project_id = google_auth_default()
    service_email = os.getenv(
        "SERVICE_ACCOUNT_EMAIL", getattr(credentials, "service_account_email", None)
    )

    if not service_email:
        raise HTTPException(status_code=500, detail="SERVICE_ACCOUNT_EMAIL no configurado")

    signer = google.auth.iam.Signer(
        request=requests.Request(),
        credentials=credentials,
        service_account_email=service_email,
    )

    url = blob.generate_signed_url(
        expiration=timedelta(minutes=minutes),
        method="GET",
        credentials=signer,
    )
    return {"url": url}
from fastapi.responses import StreamingResponse

@app.get("/artifacts/{slug}/result_stream")
def get_result_stream(slug: str):
    """
    Devuelve result.mp4 como streaming directamente desde GCS.
    Evita firma de URL y funciona con las credenciales actuales.
    """
    path = f"{slug}/result.mp4"
    blob = get_bucket().blob(path)
    if not blob.exists():
        raise HTTPException(status_code=404, detail="result.mp4 not found")

    def iter_chunks():
        # lee en chunks de 1 MiB para no cargar todo en memoria
        with blob.open("rb") as f:
            while True:
                chunk = f.read(1024 * 1024)
                if not chunk:
                    break
                yield chunk

    return StreamingResponse(iter_chunks(), media_type="video/mp4")

# === JSON signed URL (alternativo) ===
from datetime import timedelta
from fastapi.responses import JSONResponse

@app.get("/artifacts/{slug}/result_url_json")
def get_result_signed_url_json(slug: str, minutes: int = 60):
    """
    Devuelve JSON: {"url": "<signed-url>"} para {slug}/result.mp4
    No reemplaza el endpoint anterior; es alternativo y seguro.
    """
    path = f"{slug}/result.mp4"
    blob = get_bucket().blob(path)
    if not blob.exists():
        raise HTTPException(status_code=404, detail="result.mp4 not found")
    url = blob.generate_signed_url(expiration=timedelta(minutes=minutes), method="GET")
    return JSONResponse(content={"url": url})
